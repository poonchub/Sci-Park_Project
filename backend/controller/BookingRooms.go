package controller

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"sci-park_web-application/config"
	"sci-park_web-application/entity"
	"sort"
	"strings"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"

	"time"
)

// ===== Struct ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Response =====
type TimeSlotMerged struct {
	TimeSlotName string    `json:"time_slot_name"`
	StartTime    time.Time `json:"start_time"`
	EndTime      time.Time `json:"end_time"`
}

type PaymentSummary struct {
	ID         uint     `json:"id"`
	Status     string   `json:"status"`
	SlipImages []string `json:"slipImages"`
}

type BookingRoomResponse struct {
	ID              uint                 `json:"ID"`
	Room            entity.Room          `json:"Room"`
	BookingDates    []entity.BookingDate `json:"BookingDates"`
	MergedTimeSlots []TimeSlotMerged     `json:"Merged_time_slots"`
	User            entity.User          `json:"User"`
	Purpose         string               `json:"Purpose"`
	AdditionalInfo  AdditionalInfo       `json:"AdditionalInfo"`
	StatusName      string               `json:"StatusName"`
	Payment       *PaymentSummary `json:"Payment,omitempty"`
	DisplayStatus string          `json:"DisplayStatus"`
}

type AdditionalInfo struct {
	SetupStyle     string   `json:"SetupStyle"`
	Equipment      []string `json:"Equipment"`
	AdditionalNote string   `json:"AdditionalNote"`
}

// ===== Helper: ‡∏£‡∏ß‡∏° TimeSlot =====
func mergeTimeSlots(slots []entity.TimeSlot, bookingDate time.Time) []TimeSlotMerged {
	sort.Slice(slots, func(i, j int) bool {
		return slots[i].StartTime.Before(slots[j].StartTime)
	})

	var merged []TimeSlotMerged
	for _, s := range slots {
		start := time.Date(
			bookingDate.Year(),
			bookingDate.Month(),
			bookingDate.Day(),
			s.StartTime.Hour(),
			s.StartTime.Minute(),
			s.StartTime.Second(),
			0,
			time.Local,
		)

		end := time.Date(
			bookingDate.Year(),
			bookingDate.Month(),
			bookingDate.Day(),
			s.EndTime.Hour(),
			s.EndTime.Minute(),
			s.EndTime.Second(),
			0,
			time.Local,
		)

		merged = append(merged, TimeSlotMerged{
			TimeSlotName: s.TimeSlotName,
			StartTime:    start,
			EndTime:      end,
		})
	}
	return merged
}

func computeDisplayStatus(b entity.BookingRoom) string {
	if b.CancelledAt != nil {
		return "cancelled"
	}

	if len(b.Payments) == 0 {
		return "pending" // ‡∏à‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ payment record
	}

	latest := b.Payments[len(b.Payments)-1]
	pay := strings.ToLower(latest.Status.Name)
	booking := strings.ToLower(b.Status.StatusName)

	if booking == "pending" {
		return "pending" // ‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥ booking
	}

	if booking == "confirmed" {
		switch pay {
		case "pending payment":
			return "approved" // ‡∏à‡∏≠‡∏á‡∏ú‡πà‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß ‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏•‡∏¥‡∏õ
		case "pending verification":
			return "payment review"
		case "awaiting receipt", "paid":
			return "payment"
		case "rejected":
			return "rejected"
		case "refunded":
			return "refunded"
		}
	}

	if booking == "completed" {
		return "completed"
	}

	return "unknown"
}

// ===== Controller: ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Booking ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î =====
func ListBookingRooms(c *gin.Context) {
	db := config.DB()
	var bookings []entity.BookingRoom

	err := db.
		Preload("Room.Floor").
		Preload("BookingDates").
		Preload("User").
		Preload("TimeSlots").
		Preload("Status").
		Preload("Payments.Status").
		Find(&bookings).Error
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	var result []BookingRoomResponse
	for _, b := range bookings {
		// ===== 1) ‡∏£‡∏ß‡∏° slot =====
		bookingDate := time.Now()
		if len(b.BookingDates) > 0 {
			bookingDate = b.BookingDates[0].Date
		}
		merged := mergeTimeSlots(b.TimeSlots, bookingDate)

		// ===== 2) ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Booking =====
		status := b.Status.StatusName
		if b.CancelledAt != nil {
			status = "cancelled"
		}

		// ===== 3) AdditionalInfo =====
		var addInfo AdditionalInfo
		if b.AdditionalInfo != "" {
			if err := json.Unmarshal([]byte(b.AdditionalInfo), &addInfo); err != nil {
				fmt.Println("Error parsing additional_info:", err)
			}
		}

		// ===== 4) Payment Summary (‡πÄ‡∏≠‡∏≤‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏°‡∏≤) =====
		var paySummary *PaymentSummary
		if len(b.Payments) > 0 {
			latest := b.Payments[len(b.Payments)-1] // ‡πÄ‡∏≠‡∏≤ payment ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î

			statusName := ""
			if latest.Status.ID != 0 {
				statusName = latest.Status.Name
			}

			slipImages := []string{}
			if latest.SlipPath != "" {
				slipImages = append(slipImages, latest.SlipPath)
			}

			paySummary = &PaymentSummary{
				ID:         latest.ID, // ‚úÖ ‡πÉ‡∏ä‡πâ latest.ID
				Status:     uiPaymentStatus(statusName),
				SlipImages: slipImages,
			}
		}

		// ===== 5) Append ‡πÄ‡∏Ç‡πâ‡∏≤ response =====
		result = append(result, BookingRoomResponse{
			ID:              b.ID,
			Room:            b.Room,
			BookingDates:    append([]entity.BookingDate{}, b.BookingDates...),
			MergedTimeSlots: merged,
			User:            b.User,
			Purpose:         b.Purpose,
			AdditionalInfo:  addInfo,
			StatusName:      status,
			Payment:         paySummary,
			DisplayStatus:   computeDisplayStatus(b), // ‚úÖ
		})

	}

	// ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô null
	if result == nil {
		result = []BookingRoomResponse{}
	}

	fmt.Println(result)

	c.JSON(http.StatusOK, result)
}

// controller/BookingRooms.go

func ListBookingRoomsByUser(c *gin.Context) {
	db := config.DB()
	userID := c.Param("id") // ‡∏î‡∏∂‡∏á user id ‡∏à‡∏≤‡∏Å path ‡πÄ‡∏ä‡πà‡∏ô /booking-rooms/user/3

	var bookings []entity.BookingRoom

	err := db.
		Preload("Room.Floor").
		Preload("BookingDates").
		Preload("User").
		Preload("TimeSlots").
		Preload("Status").
		Preload("Payments", func(db *gorm.DB) *gorm.DB {
			return db.Order("id desc").Limit(1) // üëà ‡∏î‡∏∂‡∏á payment ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
		}).
		Preload("Payments.Status").
		Where("user_id = ?", userID).
		Find(&bookings).Error

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	var result []BookingRoomResponse
	for _, b := range bookings {
		// ===== 1) ‡∏£‡∏ß‡∏° slot =====
		bookingDate := time.Now()
		if len(b.BookingDates) > 0 {
			bookingDate = b.BookingDates[0].Date
		}
		merged := mergeTimeSlots(b.TimeSlots, bookingDate)

		// ===== 2) ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Booking =====
		status := b.Status.StatusName
		if b.CancelledAt != nil {
			status = "cancelled"
		}

		// ===== 3) AdditionalInfo =====
		var addInfo AdditionalInfo
		if b.AdditionalInfo != "" {
			if err := json.Unmarshal([]byte(b.AdditionalInfo), &addInfo); err != nil {
				fmt.Println("Error parsing additional_info:", err)
			}
		}

		// ===== 4) Payment Summary (‡πÄ‡∏≠‡∏≤‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏°‡∏≤) =====
		var paySummary *PaymentSummary
		if len(b.Payments) > 0 {
			latest := b.Payments[len(b.Payments)-1] // ‡πÄ‡∏≠‡∏≤ payment ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î

			statusName := ""
			if latest.Status.ID != 0 {
				statusName = latest.Status.Name
			}

			slipImages := []string{}
			if latest.SlipPath != "" {
				slipImages = append(slipImages, latest.SlipPath)
			}

			paySummary = &PaymentSummary{
				ID:         latest.ID, // ‚úÖ ‡πÉ‡∏ä‡πâ latest.ID
				Status:     uiPaymentStatus(statusName),
				SlipImages: slipImages,
			}
		}

		// ===== 5) Append ‡πÄ‡∏Ç‡πâ‡∏≤ response =====
		result = append(result, BookingRoomResponse{
			ID:              b.ID,
			Room:            b.Room,
			BookingDates:    append([]entity.BookingDate{}, b.BookingDates...),
			MergedTimeSlots: merged,
			User:            b.User,
			Purpose:         b.Purpose,
			AdditionalInfo:  addInfo,
			StatusName:      status,
			Payment:         paySummary,
			DisplayStatus:   computeDisplayStatus(b), // ‚úÖ
		})
	}

	// ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô null
	if result == nil {
		result = []BookingRoomResponse{}
	}

	c.JSON(http.StatusOK, result)
}

func CreateBookingRoom(c *gin.Context) {
	db := config.DB()

	type BookingInput struct {
		UserID         uint     `json:"UserID" binding:"required"`
		RoomID         uint     `json:"RoomID" binding:"required"`
		TimeSlotIDs    []uint   `json:"TimeSlotIDs" binding:"required"`
		Purpose        string   `json:"Purpose" binding:"required"`
		Dates          []string `json:"Dates" binding:"required"`
		AdditionalInfo string   `json:"AdditionalInfo"`
	}

	// ‡∏≠‡πà‡∏≤‡∏ô raw body log ‡πÄ‡∏û‡∏∑‡πà‡∏≠ debug
	bodyBytes, _ := ioutil.ReadAll(c.Request.Body)
	log.Println("Raw request body:", string(bodyBytes))
	c.Request.Body = ioutil.NopCloser(bytes.NewBuffer(bodyBytes))

	var input BookingInput
	if err := c.ShouldBindJSON(&input); err != nil {
		log.Println("Error binding JSON:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: " + err.Error()})
		return
	}

	// ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á ‡∏û‡∏£‡πâ‡∏≠‡∏° RoomStatus
	var room entity.Room
	if err := db.Preload("RoomStatus").First(&room, input.RoomID).Error; err != nil {
		log.Println("Error fetching room data:", err)
		c.JSON(http.StatusNotFound, gin.H{"error": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏∞‡∏ä‡∏∏‡∏°"})
		return
	}

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡πâ‡∏≠‡∏á
	if room.RoomStatus.Code != "available" {
		log.Println("Room is not available")
		c.JSON(http.StatusForbidden, gin.H{"error": "‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ"})
		return
	}

	// ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ + Role
	var user entity.User
	if err := db.Preload("Role").First(&user, input.UserID).Error; err != nil {
		log.Println("Error fetching user data:", err)
		c.JSON(http.StatusNotFound, gin.H{"error": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ"})
		return
	}

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà
	// ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á ‡∏û‡∏£‡πâ‡∏≠‡∏° RoomStatus + RoomType + RoomTypeLayouts
	if err := db.Preload("RoomType.RoomTypeLayouts").
		First(&room, input.RoomID).Error; err != nil {
		log.Println("Error fetching room data:", err)
		c.JSON(http.StatusNotFound, gin.H{"error": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏∞‡∏ä‡∏∏‡∏°"})
		return
	}

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà
	if len(room.RoomType.RoomTypeLayouts) > 0 {
		largestCapacity := 0
		for _, layout := range room.RoomType.RoomTypeLayouts {
			if layout.Capacity > largestCapacity {
				largestCapacity = layout.Capacity
			}
		}

		if largestCapacity > 20 && user.Role.ID != 4 && user.Role.ID != 5 {
			log.Println("User does not have permission to book large rooms")
			c.JSON(http.StatusForbidden, gin.H{
				"error": "‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏≠‡∏∏‡∏ó‡∏¢‡∏≤‡∏ô‡∏ß‡∏¥‡∏ó‡∏¢‡πå‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏≠‡∏á‡∏î‡πâ‡∏ß‡∏¢‡∏ï‡∏ô‡πÄ‡∏≠‡∏á‡πÑ‡∏î‡πâ",
			})
			return
		}
	}

	// ‡πÇ‡∏´‡∏•‡∏î TimeSlots ‡∏ï‡∏≤‡∏° TimeSlotIDs ‡∏î‡πâ‡∏ß‡∏¢ where id IN ?
	var timeSlots []entity.TimeSlot
	if err := db.Where("id IN ?", input.TimeSlotIDs).Find(&timeSlots).Error; err != nil {
		log.Println("Error fetching time slots:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á"})
		return
	}

	if len(timeSlots) == 0 {
		log.Printf("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö TimeSlotIDs ‡πÉ‡∏ô DB: %+v", input.TimeSlotIDs)
		c.JSON(http.StatusBadRequest, gin.H{"error": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å"})
		return
	}

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ã‡πâ‡∏≥‡∏Ç‡∏≠‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà + TimeSlot
	for _, dateStr := range input.Dates {
		parsedDate, err := time.Parse("2006-01-02", dateStr)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: " + dateStr})
			return
		}

		var existingCount int64
		const cancelledStatusID = 2 // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ï‡∏≤‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á‡πÉ‡∏ô DB

		err = db.Model(&entity.BookingRoom{}).
			Joins("JOIN booking_room_timeslots ON booking_rooms.id = booking_room_timeslots.booking_room_id").
			Joins("JOIN booking_dates ON booking_rooms.id = booking_dates.booking_room_id").
			Where("booking_rooms.room_id = ? AND booking_dates.date = ? AND booking_room_timeslots.time_slot_id IN ? AND booking_rooms.status_id != ?",
				input.RoomID, parsedDate.Format("2006-01-02"), input.TimeSlotIDs, cancelledStatusID).
			Count(&existingCount).Error

		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á"})
			return
		}

		if existingCount > 0 {
			c.JSON(http.StatusConflict, gin.H{
				"error": "‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ã‡πâ‡∏≥‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà " + dateStr + " ‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß",
			})
			return
		}
	}

	// ‡∏™‡∏£‡πâ‡∏≤‡∏á BookingRoom ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏° TimeSlots (many-to-many)
	booking := entity.BookingRoom{
		Purpose:        input.Purpose,
		UserID:         input.UserID,
		RoomID:         input.RoomID,
		TimeSlots:      timeSlots,
		StatusID:       1, // ‡∏™‡∏°‡∏°‡∏ï‡∏¥ status "confirmed"
		AdditionalInfo: input.AdditionalInfo,
	}

	if err := db.Create(&booking).Error; err != nil {
		log.Println("Error creating booking:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å BookingRoom ‡πÑ‡∏î‡πâ"})
		return
	}

	// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° Payment record ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏•‡∏¢
	pendingStatusID, _ := mustPaymentStatusID("Pending Payment")

	payment := entity.Payment{
		BookingRoomID: booking.ID,
		StatusID:      pendingStatusID,
		Amount:        0,              // ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏à‡πà‡∏≤‡∏¢ ‚Üí 0 ‡πÑ‡∏õ‡∏Å‡πà‡∏≠‡∏ô
		SlipPath:      "",             // ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏•‡∏¥‡∏õ
		PaymentDate:   time.Now(),     // ‡∏´‡∏£‡∏∑‡∏≠ null ‡πÑ‡∏î‡πâ‡∏ñ‡πâ‡∏≤‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏≤‡∏Å‡πÉ‡∏™‡πà
		PayerID:       booking.UserID, // default ‡∏ú‡∏π‡πâ‡∏à‡∏≠‡∏á‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡∏ô‡∏à‡πà‡∏≤‡∏¢
		Note:          "Waiting for slip upload",
	}

	if err := db.Create(&payment).Error; err != nil {
		log.Println("Error creating initial payment:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á Payment ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏î‡πâ"})
		return
	}

	// ‡πÄ‡∏û‡∏¥‡πà‡∏° BookingDate ‡∏´‡∏•‡∏≤‡∏¢‡∏ß‡∏±‡∏ô
	var bookingDates []entity.BookingDate
	for _, dateStr := range input.Dates {
		parsedDate, _ := time.Parse("2006-01-02", dateStr)
		bookingDates = append(bookingDates, entity.BookingDate{
			BookingRoomID: booking.ID,
			Date:          parsedDate,
		})
	}

	if err := db.Create(&bookingDates).Error; err != nil {
		log.Println("Error creating booking dates:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å BookingDate ‡πÑ‡∏î‡πâ"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":    "‡∏à‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
		"booking_id": booking.ID,
	})
}

func CancelBookingRoom(c *gin.Context) {
	db := config.DB()
	bookingID := c.Param("id")

	var booking entity.BookingRoom
	if err := db.
		Preload("BookingDates").
		First(&booking, bookingID).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á"})
		return
	}

	if len(booking.BookingDates) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ß‡∏±‡∏ô‡∏à‡∏≠‡∏á‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ"})
		return
	}

	// ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏ã‡πâ‡∏≥
	if booking.StatusID == 3 {
		c.JSON(http.StatusConflict, gin.H{"error": "‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß"})
		return
	}

	// ‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏£‡∏Å‡∏™‡∏∏‡∏î‡πÉ‡∏ô booking ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
	firstDate := booking.BookingDates[0].Date.Truncate(24 * time.Hour)
	today := time.Now().Truncate(24 * time.Hour)
	twoDaysLater := today.Add(48 * time.Hour)

	if firstDate.Before(twoDaysLater) {
		c.JSON(http.StatusBadRequest, gin.H{"error": "‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 2 ‡∏ß‡∏±‡∏ô‡∏•‡πà‡∏ß‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡∏ß‡∏±‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô"})
		return
	}

	// ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
	now := time.Now()
	booking.StatusID = 3
	booking.CancelledAt = &now

	if err := db.Save(&booking).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":     "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
		"cancelledAt": now.Format("2006-01-02 15:04:05"),
	})
}

// GET /booking-room/by-date
func ListBookingRoomByDateRange(c *gin.Context) {
	var booking []entity.BookingRoom

	startDateStr := c.Query("start_date")
	endDateStr := c.Query("end_date")

	db := config.DB()

	query := db.
		Preload("Status").
		Order("created_at ASC")

	layout := "2006-01-02"
	loc, err := time.LoadLocation("Asia/Bangkok")
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to load timezone"})
		return
	}

	if startDateStr != "" {
		startDate, errStart := time.ParseInLocation(layout, startDateStr, loc)
		if errStart != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid start_date format, expected YYYY-MM-DD"})
			return
		}

		if endDateStr == "" {
			startOfDay := startDate
			endOfDay := startDate.AddDate(0, 0, 1)
			query = query.Where("created_at >= ? AND created_at < ?", startOfDay, endOfDay)
		} else {
			endDate, errEnd := time.ParseInLocation(layout, endDateStr, loc)
			if errEnd != nil {
				c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid end_date format, expected YYYY-MM-DD"})
				return
			}

			endDate = endDate.AddDate(0, 0, 1)

			query = query.Where("created_at >= ? AND created_at < ?", startDate, endDate)
		}
	}

	results := query.Find(&booking)
	if results.Error != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": results.Error.Error()})
		return
	}

	c.JSON(http.StatusOK, &booking)
}
